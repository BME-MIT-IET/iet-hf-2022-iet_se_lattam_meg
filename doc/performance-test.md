# Nem-funkcionális jellemzők vizsgálata
Megvizsgáltuk a projekt nem-funkcionális jellemzőit is. A projektben különböző rendező algoritmusok implementációi vannak, amelyeknek, mint az algoritmusoknak általában, két fontos jellemzője van, az egyik, hogy milyen gyorsan hajtják végre az adott feladatot, a másik pedig, hogy mennyi memóriát használnak ehhez közben.
## Tesztelés
A tesztelés során különböző méretű, random számokkal telepakolt, tömböket generálunk először, majd ezeken hajtjuk végre a különböző rendezéseket. A rengeteg random tömb segít elfedni az esetleges egyszerűbb esetekből adódó előnyöket az  egyes algoritmusoknál, és így az átlagos jellemzőiket kaphatjuk meg, ami a lényeges adat számunkra. A generált inputokat mindig lemásoljuk az algoritmusok számára, hogy ugyanazon az adathalmazon tudjuk vizsgálni minden algoritmus jellemzőit, és így egy valósabb képet kapni arról, hogy melyik is a legjobb az egyes szempontok szerint. A tesztelés során minden algoritmus tesztje után megjelenítjük a jellemzőiket, majd az összes teszt végén a legjobbak külön szerepelnek, mind memória, mind futásidő alapján.
## Eredmény
A tesztelés során kiderült, hogy átlagosan a `quick sort` a leggyorsabb futásidejű algoritmus, melyet a `pigeon hole sort` követ, amely bizonyos input esetén meg is előzte az előbbit, ezek mögött van nem sokkal a `shell sort`, a `radix sort` és `heap sort`. Ezek mindegyike (kivéve a `radix sort`-t) sok másik algoritmussal együtt 0 (vagy közel 0) memóriát használ futás közben, mivel ezek az algoritmusok nem igényelnek külön tárhelyet, csak a meglévő tömbben dolgoznak. Memória tehát szempontból nehéz toplistát állítani, de érdekes látni, hogy a leggyorsabb algoritmusok úgy tudnak gyorsak maradni, hogy ez nem megy a memória rovására, ami például a radix esetében nem igaz, mert annak ellenére, hogy viszonylag gyors, a tárhelyigénye `O(n + k)`-s, ahol n az tömb hossza, k pedig a leghosszabb szám bitjeinek száma.